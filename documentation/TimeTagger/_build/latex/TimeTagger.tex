% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Time Tagger Documentation}
\date{June 29, 2015}
\release{1.0}
\author{Swabian Instruments}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}
{\hfill\includegraphics[width=0.900\linewidth]{logo_as_paths.png}\hfill}




\chapter{Installation instructions}
\label{sections/installation:welcome-to-time-tagger-s-documentation}\label{sections/installation::doc}\label{sections/installation:installation-instructions}

\section{Windows users}
\label{sections/installation:windows-users}

\subsection{Requirements}
\label{sections/installation:requirements}

\subsubsection{Operating System}
\label{sections/installation:operating-system}
All 32 and 64 bit windows versions since windows XP are supported.


\subsubsection{Python}
\label{sections/installation:python}
If you want to run the \textbf{quickstart guide},
or the \textbf{web application} (currently under development),
you need the following additional third-party software packages (available for free).
\begin{itemize}
\item {} 
\textbf{python 2.7.x} or \textbf{python 3.4.x} installed along with \textbf{ipython}

\item {} 
the following python modules: \textbf{numpy, matplotlib (pylab), time, cPickle}

\end{itemize}

On windows it is easiest to install a \textbf{python distribution} that contains all required
packages by default. The \textbf{anaconda} or \textbf{canopy} python distributions will cover this.
If you don't have python installed, please download and install now either
of these python distributions. Note that \textbf{anaconda} is available as \textbf{python 3.4.x}.

\begin{notice}{note}{Note:}
If you are using a fresh install of the \textbf{canopy} distribution, please make sure to run the graphical interface once from the start menu to have your python paths set up corectly.
\end{notice}


\subsubsection{Installation}
\label{sections/installation:installation}
\begin{notice}{note}{Note:}
If you intend to use the \emph{TimeTagger 20} with the Python programming language, please make sure that you install python first as described above. This ensures that the installer detects your Python installation automatically.
\end{notice}
\begin{enumerate}
\item {} 
Download and run the most recent \emph{TimeTagger 20} windows installer.

\end{enumerate}

Connect the \emph{TimeTagger 20} to your computer with the USB cable.

\begin{notice}{caution}{Caution:}
Wait until windows has recognized the device and finished installing the driver.
\end{notice}

You should now be ready to use your \emph{TimeTagger 20}.


\chapter{Getting Started}
\label{sections/gettingStarted:getting-started}\label{sections/gettingStarted::doc}\label{sections/gettingStarted:quickstart}

\section{Windows users}
\label{sections/gettingStarted:windows-users}\begin{enumerate}
\item {} 
Make sure the \emph{TimeTagger 20} software and a Python distribution are installed and the \emph{TimeTagger 20} connected to your computer (see previous section).

\item {} 
Open a command shell and \code{cd} to the \code{..\textbackslash{}examples\textbackslash{}python\textbackslash{}quickstart} folder under your \emph{TimeTagger 20} installation directory

\item {} 
Start an \textbf{ipython} shell with plotting support by entering \code{ipython -{-}pylab}

\item {} 
Run the \textbf{quickstart.py} script by entering \code{run quickstart}

\end{enumerate}

The script demonstrates a selection of the features provided by the \emph{TimeTagger 20} programming interface
and runs some example measurements using the built in test signal generator and plots the result.

You are encouraged to open and read the \code{quickstart.py} file in an editor to see what it is doing.

Among others, the script will...
\begin{enumerate}
\item {} 
Create an instance called `tagger' that represents the device.

\item {} 
Start the builtin test signal (\textasciitilde{}0.8 MHz square wave) and apply it to channels 0 a nd 1

\item {} 
Create a time trace of the click rate on the first two channels, let it run for a while and plot the result.

\item {} 
Create coarse and fine cross correlation measurements. The coarse measurement shows characteristic peaks at integer multiples of the inverse frequency of the test signal. The fine measurement demonstrates the \textless{} 60 ps time resolution.

\item {} 
Show you how to create virtual channels, use synchronization, event filter and control the input trigger level.

\end{enumerate}


\subsection{Where to go from here}
\label{sections/gettingStarted:where-to-go-from-here}
To learn more about the \emph{TimeTagger 20} you are encouraged to consult the following resources.
\begin{enumerate}
\item {} 
If you have not done so already, have a look at the Python script you just run.

\item {} 
More details about the software interface are covered by the C++ API documentation in the subsequent section

\item {} 
You are also encouraged to study the C++ source code provided in the \emph{TimeTagger 20} install directory (released under the GPL)

\item {} 
Code examples in \code{..\textbackslash{}examples\textbackslash{}python\textbackslash{}traits} show you how to quickly implement an interactive graphical interface in python

\end{enumerate}

\begin{notice}{note}{Note:}
The python GUI examples, additionally require the following python packages installed on your system: \emph{traits, traitsui, chaco, pyface enable}.
\end{notice}


\chapter{Hardware}
\label{sections/hardware:hardware}\label{sections/hardware::doc}

\section{Input channels}
\label{sections/hardware:input-channels}
The \emph{TimeTagger 20} has 8 SMA connectorized input channels numbered 0 to 7 throughout this document. The electrical
characteristics are tabulated below. Both rising and falling edges are detected on the input channels.
On the software level, rising edges correspond to channel numbers 0 to 7 and falling edges correspond to
respective channel numbers 8 to 15. Thereby, you can treat rising and falling edges in a fully equivalent fashion.


\subsection{Electrical characteristics}
\label{sections/hardware:electrical-characteristics}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Property
} & \textsf{\relax 
Value
}\\
\hline
Termination
 & 
50  \(\Omega\)
\\
\hline
Input voltage range
 & 
0 to 5 V
\\
\hline
Trigger level range
 & 
0 to 3.3 V
\\
\hline
Minimum signal level
 & 
\textasciitilde{}50 mV
\\
\hline
Minimum pulse width
 & 
\textasciitilde{}1 ns
\\
\hline\end{tabulary}



\section{Data connection}
\label{sections/hardware:data-connection}
A USB connection is used for data and power supply. Please ensure that the USB port is capable of providing the full
specified current (500 mA). A USB 2.0 data connection is required for reasonable performance. Operating the device via
a USB hub is strongly discouraged. The \emph{TimeTagger 20} can stream about 5 M tags per second.


\section{Status LEDs}
\label{sections/hardware:status-leds}
The \emph{TimeTagger 20} has two LEDs showing status information. A green LED turns on when the USB power is connected.
An RGB LED shows the information tabulated below.

\begin{tabulary}{\linewidth}{|L|L|}
\hline

green
 & 
firmware loaded
\\
\hline
blinking green-orange
 & 
time tags are streaming
\\
\hline
red flash (0.1 s)
 & 
an overflow occurred
\\
\hline
continuous red
 & 
repeated overflows
\\
\hline\end{tabulary}



\section{Test signal}
\label{sections/hardware:test-signal}
The \emph{TimeTagger 20} has a built in test signal generator that
generates a square wave with a frequency in the range 0.9 to 1.0 MHz.
You can apply the test signal to any input channel instead of the
external input. This is useful for testing, calibrating and setting up,


\section{Virtual channels}
\label{sections/hardware:virtual-channels}
The architecture allows you to create virtual channels, e.g.,
you can create a new channel that represents the sum of two channels (logical OR),
or coincidence clicks of two channels (logical AND).


\section{Synthetic input delay}
\label{sections/hardware:synthetic-input-delay}
You can introduce for each channel an input delay. This is useful
e.g. to compensate for propagation delay in cables of unequal length,
if the relative timing between two channels is important. The input delay
can be set individually for rising and for falling edges.


\section{Synthetic dead time}
\label{sections/hardware:synthetic-dead-time}
You can introduce for each channel a synthetic dead time. This is useful
when you want to suppress consecutive clicks that are closely separated,
e.g., to suppress after-pulsing of avalanche photo diodes or to suppress too
high data rates. The dead time can be set individually for rising and for falling edges.


\section{Event filter}
\label{sections/hardware:event-filter}
In a typical fluorescence lifetime application, a target is stimulated with laser pulses with
a fast repetition rate, typically in the range 10 - 100 MHz. Electrical synchronization pulses
are generated that are simultaneous with the excitation laser pulses and are sent to
the \emph{TimeTagger 20} on one channel, while single photon clicks emitted from the target are sent to another channel.
Because the data rate of the synchronization pulses is so high, streaming and processing all generated
time tags by the computer is not possible - and not necessary, since only those synchronization
pulses are of interest that are followed by a photon event. It is therefore desirable
to discard all synchronization time tags in the data stream except those that are followed by a photon.
Since the synchronization pulses are periodic with a very well defined period, it is equivalent
to keep only those synchronization time tags that are \{em preceded\} by a photon.

This feature is implemented by an event filter that is currently hardcoded between
channel 0 and channel 7. It is assumed that photon clicks are entering channel 0 and laser sync clicks
are entering channel 7. When the filter is active, time tags on channel 7 are only passed
if a time tag has been registered on channel 0 before. Subsequent tags are discarded until the next
tag on channel 0 is detected.

This filter is all you need to perform fluorescence lifetime measurements and fluorescence lifetime imaging.
If you are interested in event filters with more complex logic, please contact us for custom designs.


\section{Bin equilibration}
\label{sections/hardware:bin-equilibration}
Discretization of electrical signals is never perfect. In time-to-digital conversion, this is manifest
as small differences (few ps) of the bin sizes inside the converter that even varies from chip to chip.
This imperfection is inheret to any time-to-digital conversion hardware.
It is usually not apperent to the user. However, when correlations between two channels are measured on short
time scales you might see this as a weak periodic ripple ontop of your signal.
If you wish to turn off this ripple, you can enable an equilibration of the bin sizes
at the cost of a decrease of the time resolution by \(\sqrt{2}\). This feature is disabled by default.


\section{Overflows}
\label{sections/hardware:overflows}
Data rates are never infinite. The \emph{TimeTagger 20} is capable of streaming about 5 M tags per second,
At higher rates, data loss occurs and parts of the time tags are lost. The hardware allows you
to check whether an overflow condition has occured. If no overflow occurrs,
you can be sure that every time tag is received.


\section{General purpose IO (available upon request)}
\label{sections/hardware:general-purpose-io-available-upon-request}
The device is ready to be equipped with up to four SMA connectorized general purpose IO ports and an external clock input or output.
These can be used to implement custom features such as special fast input or output triggers, enable / disable gates,
software controllable input and output lines, etc.. Please contact us for custom designs.


\chapter{Software Overview}
\label{sections/software:software-overview}\label{sections/software::doc}
The heart of the \emph{TimeTagger 20} software is a multi-threaded driver
that receives the time tag stream and feeds it to all running
measurements. Measurements are small threads that analyze the time tag stream
each in their own way. E.g., a count rate measurement will extract all time
tags of a specific channel and calculate the average number of tags received per
second, a cross-correlation measurement will compute the cross-correlation between two
channels, typically by sorting the time tags in histograms, etc.. This is a
powerful architecture that allows you to perform any thinkable digital time domain
measurement in real time. You have several choices to use this architecture.


\section{Web application and JSON-RPC interface}
\label{sections/software:web-application-and-json-rpc-interface}
\begin{notice}{note}{Note:}
This feature is currently under development. Please contact us if you would like to use the timetagger in this way.
\end{notice}

The easiest way of using the \emph{TimeTagger 20} is via a web application
that allows you to interact with the hardware from a web browser on your computer
or a tablet. You can create measurements
and get life plots, save and load the acquired data from within a web browser.
In addition, you can also access and reomte control the web application
via a JSON-RPC interface.


\section{Precompiled libraries and high level language bindings}
\label{sections/software:precompiled-libraries-and-high-level-language-bindings}
We have implemented a set of typical measurements including count rates, auto
correlation, cross correlation, fluorescence lifetime imaging (FLIM), etc..
For most users, these measurements
will cover all needs. These measurements are included in
the C++ API and provided as precompiled library files. To make using the
TimeTagger even easier, we have equipped these libraries with
bindings to higher level languages, specifically Python so that you can directly
use the TimeTagger from this language.
With these APIs you can easily start a complex
measurement from a higher level language with only two lines of code.
To use one of these APIs, you have to write code in the high
level language of your choice. Refer to chapter \emph{quickstart} and {\hyperref[sections/api:api]{\emph{Application Programmer's Interface}}}
if you plan to use the TimeTagger in this way.

\begin{notice}{note}{Note:}
Bindings for other languages such as Java, Matlab and Labview are available upon request.
\end{notice}


\section{C++ API}
\label{sections/software:c-api}
The underlying software architecture is provided by a C++ API that implements
two classes: one class that represent the TimeTagger and one class that
represents a base measurement. Ontop of that, the C++ API also provides
all predefined measurements that are made available by the web
application and high level language bindings. To use this API, you have to
write and compile a C++ program. If you want to implement a custom
measurement you need to follow this approach. Refer to
chapter {\hyperref[sections/api:api]{\emph{Application Programmer's Interface}}} if you plan to use the TimeTagger in this way.


\chapter{Application Programmer's Interface}
\label{sections/api:application-programmer-s-interface}\label{sections/api:api}\label{sections/api::doc}

\section{Overview}
\label{sections/api:overview}
The API provides methods to control the hardware and to create
measurements that are hooked onto the time tag stream. It is written in C++ but
wrapper classes for higher level languages, specifically python
can be provided, such that the C++ API can directly be used in your application,
in a way that is equivalent to the C++ classes.
The API includes a set of typical measurements that will most likely
cover your needs. Implementation of custom measurements is based on
subclassing from a C++ base class and thus is only available in the C++ API.


\subsection{API documentation}
\label{sections/api:api-documentation}
The API documentation in this manual gives a general overview how to use the \emph{TimeTagger 20}.
More detailed information can be found in the API reference (generated with
Doxygen).
.. ToDo reference to doxygen stuff


\subsection{Examples}
\label{sections/api:examples}
Often the fastest way to learn how to use an API is by means of examples. Please see the \code{\textbackslash{}exsamples}
subfolder of your \emph{TimeTagger 20} installation for examples.


\subsection{Units}
\label{sections/api:units}
Time is measured in ps since device startup and represented by 64 bit integers. Note that this
implies that the time variable will rollover once after about 0.83 years. This
will most likely not be relevant to you unless you plan to run your software
continuously over one year and are taking data at the instance when the rollover is happening.


\subsection{Channel Numbers}
\label{sections/api:channel-numbers}
You can use the \emph{TimeTagger 20} to detect both rising and falling edges. Throughout
the software API, the rising edges are represented by channels 0 to 7 and
the falling edges are represented by channel numbers 8 to 15. Virtual channels will obtain numbers
from 16 onwards.


\section{Organization}
\label{sections/api:organization}
The API contains a \emph{small} number of \textbf{classes} which you instantiate in your code.
These \textbf{classes} are summarized below.


\subsection{Hardware}
\label{sections/api:hardware}\begin{description}
\item[{TimeTagger}] \leavevmode
Represents the hardware and provides methods to control the trigger levels, input delay, dead time, event filter and test signals.

\end{description}


\subsection{Virtual Channels}
\label{sections/api:virtual-channels}\begin{description}
\item[{Combiner}] \leavevmode
Combines two channels into one

\item[{Coincidences}] \leavevmode
Detects coincidence clicks on two or more channels within a given window

\end{description}


\subsection{Measurements}
\label{sections/api:measurements}\begin{description}
\item[{Iterator}] \leavevmode
Base class for implementing custom measurements.

\item[{Countrate}] \leavevmode
Average tag rate on one or more channels.

\item[{Counter}] \leavevmode
Counts clicks on one or more channels with a fixed binwidth and
circular buffer output.

\item[{CountBetweenMarkers}] \leavevmode
Counts tags on one channel where the bins are
determined by triggers on one or two other channels. Uses static buffer
output. Use this to implement a gated counter, a counter synchronized to
an external sampling clock, etc.

\item[{TimeDifferences}] \leavevmode
Accumulates the time differences between tags on two
channels in one or more histograms. The sweeping through
histograms is optionally controlled by one or two additional triggers.

\item[{Histogram}] \leavevmode
A simple histogram of time differences. This can be used e.g.
to measure lifetime.

\item[{Correlation}] \leavevmode
auto- and cross-correlation.

\item[{FLIM}] \leavevmode
Fluorescence lifetime imaging.

\item[{StartStop}] \leavevmode
Accumulates a histogram of time difference between
pairs of tagss on two channels. Only the first stop tag after a start tag is
considered. Subsequent stop tags are discarded. The Histogram length is
unlimited.

\end{description}


\section{The TimeTagger class}
\label{sections/api:the-timetagger-class}
This class provides access to the hardware and exposes methods to control hardware settings.
Behind the scenes it opens the USB connection, initializes the device
and receives the time tag stream. Every measurement requires an
instance of the TimeTagger class to which it will be associated. In a typical application
you will perform the following steps:
\begin{enumerate}
\item {} 
create an instance of TimeTagger

\item {} 
use methods on the instance of TimeTagger to adjust the trigger levels

\item {} 
create an instance of a measurement passing the instance of TimeTagger to the constructor

\end{enumerate}

You can use multiple TimeTaggers on one computer simultaneously. In this case, you usually want to
associate your instance of the TimeTagger class to a physical TimeTagger. To
implement this in a bullet proof way, TimeTagger instances must be created
with a factory function called `createTimeTagger'. The factory function accepts
the serial number of a physical TimeTagger as a string argument (every
TimeTagger has a unique hardware serial number). The serial number is the only argument that can
be passed. If an mpty string or no argument is passed, the first detected
TimeTagger will be used. To find out the hardware serial number, you can connect
a single timetagger, open it and use the `getSerial' function described below.

The TimeTagger class contains a small number of methods to control the hardware settings that are summarized below.


\subsection{Methods}
\label{sections/api:methods}\begin{description}
\item[{setTriggerLevel()}] \leavevmode
set the trigger level of an input channel

\item[{getTriggerLevel()}] \leavevmode
return the trigger level of an input channel

\item[{setInputDelay()}] \leavevmode
set the input delay of a channel

\item[{getInputDelay()}] \leavevmode
return the input delay of a channel

\item[{setFilter()}] \leavevmode
enable or disable the laser synchronization filter (currently hardcoded between channel 0 and 7)

\item[{getFilter()}] \leavevmode
return the state of the laser synchronization filter

\item[{setNormalization()}] \leavevmode
activate or deactivate gaussian normalization of the
detection jitter

\item[{getNormalization()}] \leavevmode
return whether input normalization is turned on

\item[{setDeadTime()}] \leavevmode
set the dead time of a channel

\item[{getDeadTime()}] \leavevmode
return the dead time of a channel

\item[{setTestSignal}] \leavevmode
apply internal test signal to a channel

\item[{getTestSignal}] \leavevmode
check whether the internal test signal is applied to a channel

\item[{getSerial()}] \leavevmode
return the hardware serial number

\item[{getOverflows()}] \leavevmode
return the number of overflows that occurred since startup

\end{description}


\section{Measurement Classes}
\label{sections/api:measurement-classes}
The library includes a number of common measurements that will be described in this section.
All measurements are derived from a base class called `Iterator' that is described further down.
As the name suggests, it uses the \emph{iterator} programming concept.
You can use this base class to write custom measurments in C++, as described in \emph{subclassing}.

All measurements provide a small number of methods to start and stop the excecution
and to access the accumulated data. The methods are summarized below.


\subsection{Methods common to all Measurements}
\label{sections/api:methods-common-to-all-measurements}\begin{description}
\item[{getData()}] \leavevmode
Returns the data accumulated up to now. The returned data can be a scalar, vector or array,
depending on the measurement.

\item[{clear()}] \leavevmode
reset the accumulated data to an array filled with zeros

\item[{start()}] \leavevmode
start data acquisition

\item[{stop()}] \leavevmode
stop data acquisition

\end{description}

\begin{notice}{attention}{Attention:}
All measurements start accumulating data immediately after their creation.
\end{notice}

In a typical application you will perform the following steps:
\begin{enumerate}
\item {} 
create an instance of a measurement, e.g.\textasciitilde{}a countrate on channel 0

\item {} 
wait for some time

\item {} 
retrieve the data accumulated by the measurement up to now by calling the `getData' method.

\end{enumerate}

The specific measurements are described below.


\subsection{Countrate}
\label{sections/api:countrate}
Measures the average countrate on one or more channels. Specifically, it
counts tags on the specified channels and determines the time between the first tag since
instantiation and the latest tag. The ratio of the number of tags and the
time corresponds to the average countrate since the first tag.


\subsubsection{Arguments}
\label{sections/api:arguments}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{channels}] \leavevmode
\textless{}vector int\textgreater{} channels used for counting tags

\end{description}


\subsubsection{Methods}
\label{sections/api:id1}\begin{description}
\item[{getData()}] \leavevmode
returns the average countrate in counts per second.

\item[{clear()}] \leavevmode
resets the accumulated counts to zero and uses the next incoming tag as the first tag.

\end{description}


\subsection{Counter}
\label{sections/api:counter}
Time trace of the countrate on one or more channels. Specifically
this measurement repeatedly counts tags on one or more channels within a
time interval `binwidth' and stores the results in a two dimensional array of size
`number of channels' times `n\_values'. The array is treated as a circular buffer that is,
all values in the array are shifted by on position when a new value is generated. The
last entry in the array is always the most recent value.


\subsubsection{Arguments}
\label{sections/api:id2}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{channels}] \leavevmode
\textless{}vector int\textgreater{} channels used for counting tags

\item[{binwidth}] \leavevmode
\textless{}longlong\textgreater{} binwidth in ps

\item[{n\_values}] \leavevmode
\textless{}int\textgreater{} number of values

\end{description}


\subsubsection{Methods}
\label{sections/api:id3}\begin{description}
\item[{getData()}] \leavevmode
returns an array of size `number of channels' times `n\_values' containing the current values of the circular buffer
(counts in each bin).

\item[{getIndex()}] \leavevmode
returns a vector of size `n\_values' containing the time bins in ps.

\item[{clear()}] \leavevmode
resets the array to zero and restarts the measurement.

\end{description}


\subsection{CountBetweenMarkers}
\label{sections/api:countbetweenmarkers}
Countrate on a single channel. The bin edges between which counts are accumulated
are determined by one or more hardware triggers. Specifically, the measurement records data into a vector of length `n\_values' (initially filled with zeros).
It waits for tags on the `begin\_channel'. When a tag is detected on the `begin\_channel' it starts counting tags
on the `click\_channel'. When the next tag is detected on the `begin\_channel' it stores the current counter value as next entry in the data vector,
resets the counter to zero and starts accumulating counts again. If an `end\_channel' is specified, the measurement stores the current counter value and resets the counter
when a tag is detected on the `end\_channel' rather than the `begin\_channel'. You can use this e.g., to accumulate counts within a gate by using
rising edges on one channel as the `begin\_channel' and falling edges on the same channel as the `end\_channel'. The measurement stops when all
entries in the data vector are filled.


\subsubsection{Arguments}
\label{sections/api:id4}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{begin\_channel}] \leavevmode
\textless{}int\textgreater{} channel that triggers beginning of counting and stepping to the next value

\item[{end\_channel}] \leavevmode
\textless{}int\textgreater{} channel that triggers end of counting

\item[{n\_values}] \leavevmode
\textless{}int\textgreater{} number of values

\end{description}


\subsubsection{Methods}
\label{sections/api:id5}\begin{description}
\item[{getData()}] \leavevmode
returns an array of size `n\_values' containing the acquired counter values.

\item[{getIndex()}] \leavevmode
returns a vector of size `n\_values' containing the time bins in ps.

\item[{clear()}] \leavevmode
resets the array to zero and restarts the measurement.

\item[{ready()}] \leavevmode
returns `true' when the entire array is filled.

\end{description}


\subsection{TimeDifferences}
\label{sections/api:timedifferences}
A multidimensional histogram measurement optionally with up to three additional channels that control how to
step through the indices of the histogram array. This is a very powerful and generic measurment.
You can use it to record cross-correlation, lifetime measurements, fluorescence lifetime imaging
and many more measurements based on pulsed excitation.
Specifically, the measurement waits for a tag on the `start\_channel', then measures the
time difference between the start tag and all subsequent tags on the `click\_channel'
and stores them in a histogram. If no `start\_channel' is specified, the `click\_channel' is used as `start\_channel'
corresponding to an auto-correlation measurement.
The histogram has a number of `n\_bins' bins of binwidth `binwidth'. Clicks that fall outside the histogram range are discarded.
Data accumulation is performed independently for all start tags. This type of measurement is frequently refered to as
`single start, multiple stop' measurement and corresponds to a full auto- or cross-correlation measurement.

The data obtained from subsequent start tags can be accumulated into the same histogram (one-dimensional measurement)
or into different histograms (two-dimensional measurement). In this way you can perform more general two-dimensional
time-difference measurements. The parameter `n\_histograms' specifies the number of histograms. After each tag
on the `next\_channel', the histogram index is incremented by one (and reset to zero after reaching the last valid index.
You can also provide a synchronization trigger that resets the histogram index by
specifying a `sync\_channel'.

Typically, you will run the measurement indefinitely until stopped by the user. However, it is also possible to
specify the maximum number of rollovers of the histogram index. In this case the measurement stops when the number of
rollovers has reached the specified value. This means that both for a one-dimensional and for a
two-dimensional measurement, it will measure until every histogram has a seen the specified number of start tags.


\subsubsection{Arguments}
\label{sections/api:id6}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{click channel}] \leavevmode
\textless{}int\textgreater{} channel that increments the count in a bin

\item[{start channel}] \leavevmode
\textless{}int\textgreater{} channel that sets start times relative to which s on the click channel are measured

\item[{next channel}] \leavevmode
\textless{}int\textgreater{} channel that increments the histogram index

\item[{sync channel}] \leavevmode
\textless{}int\textgreater{} channel that resets the histogram index to zero

\item[{binwidth}] \leavevmode
\textless{}longlong\textgreater{} binwidth in ps

\item[{n\_bins}] \leavevmode
\textless{}int\textgreater{} number of bins in each histogram

\item[{n\_histograms}] \leavevmode
\textless{}int\textgreater{} number of histograms

\end{description}


\subsubsection{Methods}
\label{sections/api:id7}\begin{description}
\item[{getData()}] \leavevmode
returns a two-dimensional array of size `n\_bins' times `n\_histograms' containing the histograms.

\item[{getIndex()}] \leavevmode
returns a vector of size `n\_bins' containing the time bins in ps.

\item[{clear()}] \leavevmode
resets the array to zero.

\item[{setMaxCounts()}] \leavevmode
set the maximum number of start clicks accepted

\item[{getCounts()}] \leavevmode
returns the number of start clicks

\item[{ready()}] \leavevmode
returns `true' when the required number of start clicks set by `setMaxCounts' has been reached

\end{description}


\subsection{Correlation}
\label{sections/api:correlation}
Accumulates time differences between clicks on two channels into
a histogram, where all ticks are considered both as start and stop
clicks and both positive and negative time differences are considered.


\subsubsection{Arguments}
\label{sections/api:id8}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{channel 1}] \leavevmode
\textless{}int\textgreater{} first channel

\item[{channel 2}] \leavevmode
\textless{}int\textgreater{} second channel

\item[{binwidth}] \leavevmode
\textless{}longlong\textgreater{} binwidth in ps

\item[{n\_bins}] \leavevmode
\textless{}int\textgreater{} the number of bins in the resulting histogram

\end{description}


\subsubsection{Methods}
\label{sections/api:id9}\begin{description}
\item[{getData()}] \leavevmode
returns a one-dimensional array of size 2*n\_bins+1 containing the histograms.

\item[{getIndex()}] \leavevmode
returns a vector of size `n\_bins' containing the time bins in ps.

\item[{clear()}] \leavevmode
resets the array to zero.

\item[{setMaxCounts()}] \leavevmode
set the maximum number of start tags accepted

\item[{getCounts()}] \leavevmode
returns the number of start tags

\item[{ready()}] \leavevmode
returns `true' when the required number of start tags set by `setMaxCounts' has been reached

\end{description}


\subsection{FLIM}
\label{sections/api:flim}
Fluorescence lifetime imaging. Specifically, the measurement performs a single-start-multiple-stop measurement
and accumulates the time differences into a histogram with specified binwidth and number of bins. The condition
for moving to the next pixel can either be a pixel trigger on a third channel or a predefined accumulation
time per pixel. After accumulating a number of `pixels' histograms, the measurement stops. This measurement
is also useful to record cross-correlation on multiple pixels.


\subsubsection{Arguments}
\label{sections/api:id10}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{click\_channel}] \leavevmode
\textless{}int\textgreater{} channel that increments the count in a bin

\item[{start\_channel}] \leavevmode
\textless{}int\textgreater{} channel that sets start times relative to which clicks on the click channel are measured

\item[{next\_channel}] \leavevmode
\textless{}int\textgreater{} channel that increments the histogram index

\item[{binwidth}] \leavevmode
\textless{}longlong\textgreater{} binwidth in ps

\item[{n\_bins}] \leavevmode
\textless{}int\textgreater{} number of bins in each histogram

\item[{n\_pixels}] \leavevmode
\textless{}int\textgreater{} number of pixels

\end{description}


\subsubsection{Methods}
\label{sections/api:id11}\begin{description}
\item[{getData()}] \leavevmode
returns a two-dimensional array of size `pixels' times `bins' containing the histograms.

\item[{getIndex()}] \leavevmode
returns a vector of size `n\_pixels' containing the pixel times in ps.

\item[{clear()}] \leavevmode
resets the array to zero.

\item[{ready()}] \leavevmode
returns `true' when the measurement is ready

\end{description}


\subsection{Dump}
\label{sections/api:dump}
Dump the time tag stream to a file in a binary format.


\subsubsection{Arguments}
\label{sections/api:id12}\begin{description}
\item[{\textless{}str\textgreater{} filename}] \leavevmode
name of the file to dump to

\end{description}


\subsubsection{Methods}
\label{sections/api:id13}\begin{description}
\item[{stop()}] \leavevmode
stop the measurement

\end{description}


\section{Defining custom measurements by subclassing Iterator}
\label{sections/api:defining-custom-measurements-by-subclassing-iterator}\label{sections/api:subclassing}
This section is under construction..


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
