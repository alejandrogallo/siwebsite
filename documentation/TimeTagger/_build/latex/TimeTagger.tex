% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{Time Tagger Documentation}
\date{Jul 28, 2016}
\release{1.0.2}
\author{Swabian Instruments}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Installation instructions}
\label{sections/installation:welcome-to-time-tagger-s-documentation}\label{sections/installation::doc}\label{sections/installation:installation-instructions}

\section{Windows users}
\label{sections/installation:windows-users}

\subsection{Requirements}
\label{sections/installation:requirements}

\subsubsection{Operating System}
\label{sections/installation:operating-system}
The installer provided supports Windows 7 and Windows 10 (32 and 64 bit).


\subsubsection{Python}
\label{sections/installation:python}
If you want to run the Python \textbf{quickstart guide}, you need the following additional third-party software packages (available for free).
\begin{itemize}
\item {} 
\textbf{Python 2.7.x} or \textbf{Python 3.5.x} installed along with \textbf{ipython}

\item {} 
the following Python modules: \textbf{numpy, matplotlib (pylab), time, cPickle}

\end{itemize}

On Windows it is easiest to install a \textbf{Python distribution} that contains all required
packages by default. The \textbf{anaconda} or \textbf{canopy} Python distributions will cover this.
If you don't have Python installed, please download and install now either
of these Python distributions. Note that \textbf{anaconda} is available as \textbf{Python 3.5.x}.

\begin{notice}{note}{Note:}
If you are using a fresh install of the \textbf{canopy} distribution, please make sure to run the graphical interface once from the start menu to have your Python paths set up correctly.
\end{notice}


\subsubsection{Installation}
\label{sections/installation:installation}
\begin{notice}{note}{Note:}
If you intend to use the \emph{TimeTagger 20} with the Python programming language, please make sure that you install Python first as described above. This ensures that the installer detects your Python installation automatically.
\end{notice}
\begin{enumerate}
\item {} 
Download and run the most recent \emph{TimeTagger 20} windows installer.

\end{enumerate}

Connect the \emph{TimeTagger 20} to your computer with the USB cable.

\begin{notice}{caution}{Caution:}
Wait until windows has recognized the device and finished installing the driver.
\end{notice}

You should now be ready to use your \emph{TimeTagger 20}.


\section{Linux users}
\label{sections/installation:linux-users}
The TimeTagger can be used under Linux with C++ or Python. There is no installer package yet, so please contact us if you want to use the TimeTagger under Linux.


\chapter{Getting Started}
\label{sections/gettingStarted:quickstart}\label{sections/gettingStarted:getting-started}\label{sections/gettingStarted::doc}

\section{Windows users}
\label{sections/gettingStarted:windows-users}\begin{enumerate}
\item {} 
Make sure the \emph{TimeTagger 20} software and a Python distribution are installed and the \emph{TimeTagger 20} connected to your computer (see previous section).

\item {} 
Open a command shell and \code{cd} to the \code{.\textbackslash{}examples\textbackslash{}python\textbackslash{}quickstart} folder under your \emph{TimeTagger 20} installation directory

\item {} 
Start an \textbf{ipython} shell with plotting support by entering \code{ipython -{-}pylab}

\item {} 
Run the \textbf{quickstart.py} script by entering \code{run quickstart}

\end{enumerate}

The script demonstrates a selection of the features provided by the \emph{TimeTagger 20} programming interface
and runs some example measurements using the built in test signal generator and plots the result.

You are encouraged to open and read the \code{quickstart.py} file in an editor to see what it is doing.

Among others, the script will...
\begin{enumerate}
\item {} 
Create an instance called `tagger' that represents the device.

\item {} 
Start the built in test signal (\textasciitilde{}0.8 MHz square wave) and apply it to channels 0 and 1

\item {} 
Create a time trace of the click rate on the first two channels, let it run for a while and plot the result.

\item {} 
Create coarse and fine cross correlation measurements. The coarse measurement shows characteristic peaks at integer multiples of the inverse frequency of the test signal. The fine measurement demonstrates the \textless{} 60 ps time resolution.

\item {} 
Show you how to create virtual channels, use synchronization, event filter and control the input trigger level.

\end{enumerate}


\subsection{Where to go from here}
\label{sections/gettingStarted:where-to-go-from-here}
To learn more about the \emph{TimeTagger 20} you are encouraged to consult the following resources.
\begin{enumerate}
\item {} 
If you have not done so already, have a look at the Python script you just run.

\item {} 
More details about the software interface are covered by the API documentation in the subsequent section

\item {} 
You are also encouraged to study the C++ source code provided in the \emph{TimeTagger 20} install directory

\item {} 
Code examples in \code{.\textbackslash{}examples\textbackslash{}python\textbackslash{}traits} show you how to quickly implement an interactive graphical interface in python

\end{enumerate}

\begin{notice}{note}{Note:}
The python GUI examples, additionally require the following python packages installed on your system: \emph{traits, traitsui, chaco, pyface enable}.
\end{notice}


\subsection{DLL/wrappers for .net (e.g. Matlab, LabView)}
\label{sections/gettingStarted:dll-wrappers-for-net-e-g-matlab-labview}
We provide for the TimeTagger a .net class Library (32 and 64 bit) which can be used to access the TimeTagger from high level languages \code{.\textbackslash{}dotNet\textbackslash{}TTCSharpxx.dll}.

The following is important to note:
\begin{itemize}
\item {} 
Namespace: \code{SwabianInstruments.TimeTagger}

\item {} 
static functions (e.g. to create an instance of a TimeTagger) are accessible via \code{SwabianInstruments.TimeTagger.TT}

\end{itemize}


\subsection{LabView}
\label{sections/gettingStarted:labview}
A simple correlation measurement is provided in \code{.\textbackslash{}examples\textbackslash{}LabView\textbackslash{}} for LabView 2014.
The requirements for Using .NET assemblies in LabVIEW can be found can be found here:
* Link \textless{}\url{http://zone.ni.com/reference/en-XX/help/371361L-01/lvconcepts/net\_defaults/}\textgreater{}

\begin{notice}{note}{Note:}
LabView most likely is installed as a 32 bit version so include the 32 bit .net library to your project
\end{notice}


\subsection{Matlab}
\label{sections/gettingStarted:matlab}
Wrapper classes are provided for Matlab so that native Matlab variables can be used.

The TimeTagger toolbox is automatically installed during the setup. If \code{TimeTagger} is not available in your Matlab environment try to reinstall the toolbox from
\code{.\textbackslash{}MatlabWrapper\textbackslash{}TimeTagger Matlab.mltbx}.

The following changes in respect to the .net library have been made:
\begin{itemize}
\item {} 
static functions are available through the \code{TimeTagger} class

\item {} 
all classes except for the TimeTagger class itself have a \code{TT} prefix (e.g. \code{TTCountrate}) to not collide with any variables/classes in your Matlab environment

\end{itemize}

An example how to use the TimeTagger with Matlab can be found in \code{.\textbackslash{}examples\textbackslash{}MatLab\textbackslash{}}.


\chapter{Hardware}
\label{sections/hardware:hardware}\label{sections/hardware::doc}

\section{Input channels}
\label{sections/hardware:input-channels}
The \emph{TimeTagger 20} has 8 SMA connectorized input channels numbered 0 to 7 throughout this document. The electrical
characteristics are tabulated below. Both rising and falling edges are detected on the input channels.
On the software level, rising edges correspond to channel numbers 0 to 7 and falling edges correspond to
respective channel numbers 8 to 15. Thereby, you can treat rising and falling edges in a fully equivalent fashion.


\subsection{Electrical characteristics}
\label{sections/hardware:electrical-characteristics}
\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Property
} & \textsf{\relax 
Value
}\\
\hline
Termination
 & 
50  \(\Omega\)
\\
\hline
Input voltage range
 & 
0 to 5 V
\\
\hline
Trigger level range
 & 
0 to 3.3 V
\\
\hline
Minimum signal level
 & 
\textasciitilde{}50 mV
\\
\hline
Minimum pulse width
 & 
\textasciitilde{}1 ns
\\
\hline\end{tabulary}



\section{Data connection}
\label{sections/hardware:data-connection}
A USB connection is used for data and power supply. Please ensure that the USB port is capable of providing the full
specified current (500 mA). A USB 2.0 data connection is required for reasonable performance. Operating the device via
a USB hub is strongly discouraged. The \emph{TimeTagger 20} can stream about 5 M tags per second.


\section{Status LEDs}
\label{sections/hardware:status-leds}
The \emph{TimeTagger 20} has two LEDs showing status information. A green LED turns on when the USB power is connected.
An RGB LED shows the information tabulated below.

\noindent\begin{tabulary}{\linewidth}{|L|L|}
\hline

green
 & 
firmware loaded
\\
\hline
blinking green-orange
 & 
time tags are streaming
\\
\hline
red flash (0.1 s)
 & 
an overflow occurred
\\
\hline
continuous red
 & 
repeated overflows
\\
\hline\end{tabulary}



\section{Test signal}
\label{sections/hardware:test-signal}
The \emph{TimeTagger 20} has a built in test signal generator that
generates a square wave with a frequency in the range 0.9 to 1.0 MHz.
You can apply the test signal to any input channel instead of the
external input. This is useful for testing, calibrating and setting up,


\section{Virtual channels}
\label{sections/hardware:virtual-channels}
The architecture allows you to create virtual channels, e.g.,
you can create a new channel that represents the sum of two channels (logical OR),
or coincidence clicks of two channels (logical AND).


\section{Synthetic input delay}
\label{sections/hardware:synthetic-input-delay}
You can introduce for each channel an input delay. This is useful
e.g. to compensate for propagation delay in cables of unequal length,
if the relative timing between two channels is important. The input delay
can be set individually for rising and for falling edges.


\section{Synthetic dead time}
\label{sections/hardware:synthetic-dead-time}
You can introduce for each channel a synthetic dead time. This is useful
when you want to suppress consecutive clicks that are closely separated,
e.g., to suppress after-pulsing of avalanche photo diodes or to suppress too
high data rates. The dead time can be set individually for rising and for falling edges.


\section{Event filter}
\label{sections/hardware:event-filter}
In a typical fluorescence lifetime application, a target is stimulated with laser pulses with
a fast repetition rate, typically in the range 10 - 100 MHz. Electrical synchronization pulses
are generated that are simultaneous with the excitation laser pulses and are sent to
the \emph{TimeTagger 20} on one channel, while single photon clicks emitted from the target are sent to another channel.
Because the data rate of the synchronization pulses is so high, streaming and processing all generated
time tags by the computer is not possible - and not necessary, since only those synchronization
pulses are of interest that are followed by a photon event. It is therefore desirable
to discard all synchronization time tags in the data stream except those that are followed by a photon.
Since the synchronization pulses are periodic with a very well defined period, it is equivalent
to keep only those synchronization time tags that are \{em preceded\} by a photon.

This feature is implemented by an event filter that is currently hard coded between
channel 0 and channel 7. It is assumed that photon clicks are entering channel 0 and laser sync clicks
are entering channel 7. When the filter is active, time tags on channel 7 are only passed
if a time tag has been registered on channel 0 before. Subsequent tags are discarded until the next
tag on channel 0 is detected.

This filter is all you need to perform fluorescence lifetime measurements and fluorescence lifetime imaging.
If you are interested in event filters with more complex logic, please contact us for custom designs.


\section{Bin equilibration}
\label{sections/hardware:bin-equilibration}
Discretization of electrical signals is never perfect. In time-to-digital conversion, this is manifest
as small differences (few ps) of the bin sizes inside the converter that even varies from chip to chip.
This imperfection is inherent to any time-to-digital conversion hardware.
It is usually not apparent to the user. However, when correlations between two channels are measured on short
time scales you might see this as a weak periodic ripple on top of your signal.
If you wish to turn off this ripple, you can enable an equilibration of the bin sizes
at the cost of a decrease of the time resolution by \(\sqrt{2}\). This feature is disabled by default.


\section{Overflows}
\label{sections/hardware:overflows}
The \emph{TimeTagger 20} is capable of streaming on average about 5 million tags per second.
Higher data rates for short times will be buffered internally so that no overflow occurs.
This internal buffer is limited so that on continuously higher data rates, data loss occurs and parts of the time tags are lost. The hardware allows you
to check with \code{timeTagger.getOverflows()} whether an overflow condition has occurred. If no overflow is returned, you can be sure that every time tag is received.


\section{General purpose IO (available upon request)}
\label{sections/hardware:general-purpose-io-available-upon-request}
The device is ready to be equipped with up to four SMA connectorized general purpose IO ports and an external clock input or output.
These can be used to implement custom features such as special fast input or output triggers, enable / disable gates,
software controllable input and output lines, etc.. Please contact us for custom designs.


\chapter{Software Overview}
\label{sections/software:software-overview}\label{sections/software::doc}
The heart of the \emph{TimeTagger 20} software is a multi-threaded driver
that receives the time tag stream and feeds it to all running
measurements. Measurements are small threads that analyze the time tag stream
each in their own way. For example, a count rate measurement will extract all time
tags of a specific channel and calculate the average number of tags received per
second, a cross-correlation measurement will compute the cross-correlation between two
channels, typically by sorting the time tags in histograms, etc.. This is a
powerful architecture that allows you to perform any thinkable digital time domain
measurement in real time. You have several choices to use this architecture.


\section{Web application and JSON-RPC interface}
\label{sections/software:web-application-and-json-rpc-interface}
\begin{notice}{note}{Note:}
This feature is currently under development. Please contact us if you would like to use the TimeTagger in this way.
\end{notice}

The easiest way of using the \emph{TimeTagger 20} is via a web application
that allows you to interact with the hardware from a web browser on your computer
or a tablet. You can create measurements
and get life plots, save and load the acquired data from within a web browser.
In addition, you can also access and remote control the web application
via a JSON-RPC interface.


\section{Precompiled libraries and high level language bindings}
\label{sections/software:precompiled-libraries-and-high-level-language-bindings}
We have implemented a set of typical measurements including count rates, auto
correlation, cross correlation, fluorescence lifetime imaging (FLIM), etc..
For most users, these measurements
will cover all needs. These measurements are included in
the C++ API and provided as precompiled library files. To make using the
TimeTagger even easier, we have equipped these libraries with
bindings to higher level languages (Python, Matlab, LabView, .net in general) so that you can directly
use the TimeTagger from this language.
With these APIs you can easily start a complex
measurement from a higher level language with only two lines of code.
To use one of these APIs, you have to write code in the high
level language of your choice. Refer to chapter {\hyperref[sections/gettingStarted:quickstart]{\crossref{\DUrole{std,std-ref}{Getting Started}}}} and {\hyperref[sections/api:api]{\crossref{\DUrole{std,std-ref}{Application Programmer's Interface}}}}
if you plan to use the TimeTagger in this way.


\section{C++ API}
\label{sections/software:c-api}
The underlying software architecture is provided by a C++ API that implements
two classes: one class that represent the TimeTagger and one class that
represents a base measurement. On top of that, the C++ API also provides
all predefined measurements that are made available by the web
application and high level language bindings. To use this API, you have to
write and compile a C++ program.


\chapter{Application Programmer's Interface}
\label{sections/api:api}\label{sections/api::doc}\label{sections/api:application-programmer-s-interface}

\section{Overview}
\label{sections/api:overview}
The API provides methods to control the hardware and to create
measurements that are hooked onto the time tag stream. It is written in C++ but
wrapper classes for higher level languages (python, Matlab, LabView)
are provided, such that the C++ API can directly be used in your application,
in a way that is equivalent to the C++ classes.
The API includes a set of typical measurements that will most likely
cover your needs. Implementation of custom measurements is based on
subclassing from a C++ base class and thus is only available in the C++ API.


\subsection{API documentation}
\label{sections/api:api-documentation}
The API documentation in this manual gives a general overview how to use the \emph{TimeTagger 20}.


\subsection{Examples}
\label{sections/api:examples}
Often the fastest way to learn how to use an API is by means of examples. Please see the \code{\textbackslash{}examples}
subfolder of your \emph{TimeTagger 20} installation for examples.


\subsection{Units}
\label{sections/api:units}
Time is measured in ps since device startup and represented by 64 bit integers. Note that this
implies that the time variable will rollover once after about 0.83 years. This
will most likely not be relevant to you unless you plan to run your software
continuously over one year and are taking data at the instance when the rollover is happening.


\subsection{Channel Numbers}
\label{sections/api:channel-numbers}
You can use the \emph{TimeTagger 20} to detect both rising and falling edges. Throughout
the software API, the rising edges are represented by channels 0 to 7 and
the falling edges are represented by channel numbers 8 to 15. Virtual channels will obtain numbers
from 16 onwards.


\subsection{Undefined Channels}
\label{sections/api:undefined-channels}
There might be the need to leave a parameter undefined when calling a class constructor.
Depending on the programming language you are using you pass an undefined channel via the
static constant \code{CHANNEL\_UNDEFINED} which can be found in the \code{TT} class for .net and
in the \code{TimeTagger} class in Matlab.


\section{Organization}
\label{sections/api:organization}
The API contains a \emph{small} number of \textbf{classes} which you instantiate in your code.
These \textbf{classes} are summarized below.


\subsection{Hardware}
\label{sections/api:hardware}\begin{description}
\item[{TimeTagger}] \leavevmode
Represents the hardware and provides methods to control the trigger levels, input delay, dead time, event filter and test signals.

\end{description}


\subsection{Virtual Channels}
\label{sections/api:virtual-channels}\begin{description}
\item[{Combiner}] \leavevmode
Combines two channels into one

\item[{Coincidences}] \leavevmode
Detects coincidence clicks on two or more channels within a given window

\end{description}


\subsection{Measurements}
\label{sections/api:measurements}\begin{description}
\item[{Correlation}] \leavevmode
auto- and cross-correlation.

\item[{CountBetweenMarkers}] \leavevmode
Counts tags on one channel where the bins are
determined by triggers on one or two other channels. Uses static buffer
output. Use this to implement a gated counter, a counter synchronized to
an external sampling clock, etc.

\item[{Counter}] \leavevmode
Counts clicks on one or more channels with a fixed binwidth and
circular buffer output.

\item[{Countrate}] \leavevmode
Average tag rate on one or more channels.

\item[{FLIM}] \leavevmode
Fluorescence lifetime imaging.

\item[{Iterator}] \leavevmode
Base class for implementing custom measurements.

\item[{Histogram}] \leavevmode
A simple histogram of time differences. This can be used e.g.
to measure lifetime.

\item[{StartStop}] \leavevmode
Accumulates a histogram of time difference between
pairs of tags on two channels. Only the first stop tag after a start tag is
considered. Subsequent stop tags are discarded. The Histogram length is
unlimited.

\item[{TimeDifferences}] \leavevmode
Accumulates the time differences between tags on two
channels in one or more histograms. The sweeping through
histograms is optionally controlled by one or two additional triggers.

\end{description}


\section{The TimeTagger class}
\label{sections/api:the-timetagger-class}
This class provides access to the hardware and exposes methods to control hardware settings.
Behind the scenes it opens the USB connection, initializes the device
and receives the time tag stream. Every measurement requires an
instance of the TimeTagger class to which it will be associated. In a typical application
you will perform the following steps:
\begin{enumerate}
\item {} 
create an instance of TimeTagger

\item {} 
use methods on the instance of TimeTagger to adjust the trigger levels

\item {} 
create an instance of a measurement passing the instance of TimeTagger to the constructor

\end{enumerate}

You can use multiple TimeTaggers on one computer simultaneously. In this case, you usually want to
associate your instance of the TimeTagger class to a physical TimeTagger. To
implement this in a bullet proof way, TimeTagger instances must be created
with a factory function called `createTimeTagger'. The factory function accepts
the serial number of a physical TimeTagger as a string argument (every
TimeTagger has a unique hardware serial number). The serial number is the only argument that can
be passed. If an empty string or no argument is passed, the first detected
TimeTagger will be used. To find out the hardware serial number, you can connect
a single TimeTagger, open it and use the `getSerial' function described below.

The TimeTagger class contains a small number of methods to control the hardware settings that are summarized below.


\subsection{Methods}
\label{sections/api:methods}\begin{description}
\item[{reset()}] \leavevmode
reset the TimeTagger to the startup state

\item[{setTriggerLevel(unsigned int channel, double voltage)}] \leavevmode
set the trigger level of an input channel in volts

\item[{double getTriggerLevel(unsigned int channel)}] \leavevmode
return the trigger level of an input channel in volts

\item[{setInputDelay(unsigned int channel, long long delay)}] \leavevmode
set the input delay of a channel in picoseconds

\item[{long long getInputDelay(unsigned int channel)}] \leavevmode
return the input delay of a channel in picoseconds

\item[{setFilter(bool state)}] \leavevmode
enable or disable the event filter on the FPGA board. If the filter
is active, tags on channel 7 are only transmitted if they were
immediately preceded by a tag on channel 0.

\item[{bool getFilter()}] \leavevmode
returns true if the event filter on the FPGA board is enabled

\item[{setNormalization(bool state)}] \leavevmode
enables or disable Gaussian normalization of the
detection jitter. Enabled by default.

\item[{bool getNormalization()}] \leavevmode
returns true if Gaussian normalization is enabled.

\item[{long long setDeadTime(unsigned int channel, long long deadtime)}] \leavevmode
sets the dead time of a channel in picoseconds. The requested time will
be rounded to the nearest multiple of the clock time. The deadtime will also
be clamped to device specific limitations. As the actual deadtime will
be altered, the real value will be returned.

\item[{long long getDeadTime(unsigned int channel)}] \leavevmode
returns the dead time of a channel in picoseconds

\item[{setTestSignal(unsigned int, bool state)}] \leavevmode
This will connect or disconnect the channel with the on-chip
uncorrelated signal generator.

\item[{bool getTestSignal(unsigned int channel)}] \leavevmode
returns true if the internal test signal is activated on the specified channel

\item[{string getSerial()}] \leavevmode
returns the hardware serial number

\item[{long long getOverflows()}] \leavevmode
returns the number of overflows that occurred since startup

\item[{long long getOverflowsAndClear()}] \leavevmode
returns the number of overflows that occurred since startup and sets them to zero

\item[{clearOverflows()}] \leavevmode
set the overflow counter to zero

\item[{sync()}] \leavevmode
ensure that all hardware settings such as trigger levels,
channel registrations, etc., have propagated to the FPGA
and are physically active and synchronize the TimeTagger pipeline,
so that all tags arriving after a sync call were actually produced
after the sync call. The sync function waits until all historic
tags in the pipeline are processed.

\end{description}


\subsection{Debug Methods}
\label{sections/api:debug-methods}\begin{description}
\item[{int getBoardModel()}] \leavevmode
returns the hardware type

\item[{registerChannel(unsigned int channel)}] \leavevmode
enable transmissions of time tags on the specified channel

\item[{unregisterChannel(unsigned int channel)}] \leavevmode
disable transmissions of time tags on the specified channel

\item[{unsigned int getChannels()}] \leavevmode
returns the number of registered channels

\item[{autoCalibration(bool verbose=true)}] \leavevmode
run an auto calibration of the tagger hardware using the built in test signal

\item[{2D array long long getDistributionCount()}] \leavevmode
returns the calibration data represented in counts

\item[{2D array long long getDistributionPSec()}] \leavevmode
returns the calibration data in picoseconds

\item[{long long getPsPerClock()}] \leavevmode
returns the the duration of a clock cycle in picoseconds

\end{description}


\section{Measurement Classes}
\label{sections/api:measurement-classes}
The library includes a number of common measurements that will be described in this section.
All measurements are derived from a base class called `Iterator' that is described further down.
As the name suggests, it uses the \titleref{iterator} programming concept.

All measurements provide a small number of methods to start and stop the execution
and to access the accumulated data. The methods are summarized below.


\subsection{Methods common to all Measurements}
\label{sections/api:methods-common-to-all-measurements}\begin{description}
\item[{getData()}] \leavevmode
Returns the data accumulated up to now. The returned data can be a scalar, vector or array,
depending on the measurement.

\item[{clear()}] \leavevmode
reset the accumulated data to an array filled with zeros

\item[{start()}] \leavevmode
start data acquisition

\item[{stop()}] \leavevmode
stop data acquisition

\end{description}

\begin{notice}{attention}{Attention:}
All measurements start accumulating data immediately after their creation.
\end{notice}

In a typical application you will perform the following steps:
\begin{enumerate}
\item {} 
create an instance of a measurement, e.g.\textasciitilde{}a countrate on channel 0

\item {} 
wait for some time

\item {} 
retrieve the data accumulated by the measurement up to now by calling the `getData' method.

\end{enumerate}

The specific measurements are described below.


\subsection{Correlation}
\label{sections/api:correlation}
Accumulates time differences between clicks on two channels into
a histogram, where all ticks are considered both as start and stop
clicks and both positive and negative time differences are considered.


\subsubsection{Arguments}
\label{sections/api:arguments}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{channel 1}] \leavevmode
\textless{}int\textgreater{} first channel

\item[{channel 2}] \leavevmode
\textless{}int\textgreater{} second channel

\item[{binwidth}] \leavevmode
\textless{}longlong\textgreater{} binwidth in ps

\item[{n\_bins}] \leavevmode
\textless{}int\textgreater{} the number of bins in the resulting histogram

\end{description}


\subsubsection{Methods}
\label{sections/api:id1}\begin{description}
\item[{getData()}] \leavevmode
returns a one-dimensional array of size 2*n\_bins+1 containing the histograms.

\item[{getIndex()}] \leavevmode
returns a vector of size `n\_bins' containing the time bins in ps.

\item[{clear()}] \leavevmode
resets the array to zero.

\item[{setMaxCounts()}] \leavevmode
set the maximum number of start tags accepted

\item[{getCounts()}] \leavevmode
returns the number of start tags

\item[{ready()}] \leavevmode
returns `true' when the required number of start tags set by `setMaxCounts' has been reached

\end{description}


\subsection{CountBetweenMarkers}
\label{sections/api:countbetweenmarkers}
Countrate on a single channel. The bin edges between which counts are accumulated
are determined by one or more hardware triggers. Specifically, the measurement records data into a vector of length `n\_values' (initially filled with zeros).
It waits for tags on the `begin\_channel'. When a tag is detected on the `begin\_channel' it starts counting tags
on the `click\_channel'. When the next tag is detected on the `begin\_channel' it stores the current counter value as next entry in the data vector,
resets the counter to zero and starts accumulating counts again. If an `end\_channel' is specified, the measurement stores the current counter value and resets the counter
when a tag is detected on the `end\_channel' rather than the `begin\_channel'. You can use this e.g., to accumulate counts within a gate by using
rising edges on one channel as the `begin\_channel' and falling edges on the same channel as the `end\_channel'. The measurement stops when all
entries in the data vector are filled.


\subsubsection{Arguments}
\label{sections/api:id2}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{begin\_channel}] \leavevmode
\textless{}int\textgreater{} channel that triggers beginning of counting and stepping to the next value

\item[{end\_channel}] \leavevmode
\textless{}int\textgreater{} channel that triggers end of counting

\item[{n\_values}] \leavevmode
\textless{}int\textgreater{} number of values

\end{description}


\subsubsection{Methods}
\label{sections/api:id3}\begin{description}
\item[{getData()}] \leavevmode
returns an array of size `n\_values' containing the acquired counter values.

\item[{getIndex()}] \leavevmode
returns a vector of size `n\_values' containing the time bins in ps.

\item[{clear()}] \leavevmode
resets the array to zero and restarts the measurement.

\item[{ready()}] \leavevmode
returns `true' when the entire array is filled.

\end{description}


\subsection{Counter}
\label{sections/api:counter}
Time trace of the countrate on one or more channels. Specifically
this measurement repeatedly counts tags on one or more channels within a
time interval `binwidth' and stores the results in a two dimensional array of size
`number of channels' times `n\_values'. The array is treated as a circular buffer that is,
all values in the array are shifted by on position when a new value is generated. The
last entry in the array is always the most recent value.


\subsubsection{Arguments}
\label{sections/api:id4}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{channels}] \leavevmode
\textless{}vector int\textgreater{} channels used for counting tags

\item[{binwidth}] \leavevmode
\textless{}longlong\textgreater{} binwidth in ps

\item[{n\_values}] \leavevmode
\textless{}int\textgreater{} number of values

\end{description}


\subsubsection{Methods}
\label{sections/api:id5}\begin{description}
\item[{getData()}] \leavevmode
returns an array of size `number of channels' times `n\_values' containing the current values of the circular buffer
(counts in each bin).

\item[{getIndex()}] \leavevmode
returns a vector of size `n\_values' containing the time bins in ps.

\item[{clear()}] \leavevmode
resets the array to zero and restarts the measurement.

\end{description}


\subsection{Countrate}
\label{sections/api:countrate}
Measures the average countrate on one or more channels. Specifically, it
counts tags on the specified channels and determines the time between the first tag since
instantiation and the latest tag. The ratio of the number of tags and the
time corresponds to the average countrate since the first tag.


\subsubsection{Arguments}
\label{sections/api:id6}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{channels}] \leavevmode
\textless{}vector int\textgreater{} channels used for counting tags

\end{description}


\subsubsection{Methods}
\label{sections/api:id7}\begin{description}
\item[{getData()}] \leavevmode
returns the average countrate in counts per second.

\item[{clear()}] \leavevmode
resets the accumulated counts to zero and uses the next incoming tag as the first tag.

\end{description}


\subsection{FLIM}
\label{sections/api:flim}
Fluorescence-lifetime imaging microscopy or FLIM is an imaging technique
for producing an image based on the differences in the exponential decay rate
of the fluorescence from a sample.

Fluorescence lifetimes can be determined in the time domain by using a pulsed source. When a population
of fluorophores is excited by an ultrashort or delta pulse of light, the time-resolved fluorescence will
decay exponentially.

This measurement implements a line scan in a FLIM image that
consists of a sequence of pixels. This could either represent a single line
of the image, or - if the image is represented as a single meandering line -
this could represent the entire image.

This measurement is a special case of the more general `TimeDifferences' measurement.

The measurement successively acquires n histograms
(one for each pixel in the line scan), where each histogram
is determined by the number of bins and the binwidth.


\subsubsection{Arguments}
\label{sections/api:id8}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{click channel}] \leavevmode
\textless{}int\textgreater{} channel on which clicks are received

\item[{start channel}] \leavevmode
\textless{}int\textgreater{} channel on which start clicks are received

\item[{next\_channel}] \leavevmode
\textless{}int\textgreater{} channel on which pixel triggers are received

\item[{binwidth}] \leavevmode
\textless{}longlong\textgreater{} binwidth in ps

\item[{n\_bins}] \leavevmode
\textless{}int\textgreater{} number of bins in each histogram

\item[{n\_pixels}] \leavevmode
\textless{}int\textgreater{} number of pixels

\end{description}


\subsubsection{Methods}
\label{sections/api:id9}\begin{description}
\item[{getData()}] \leavevmode
returns a two-dimensional array of size `n\_bins' times `n\_pixels' containing the histograms.

\item[{getIndex()}] \leavevmode
returns a vector of size `n\_bins' containing the time bins in ps.

\item[{clear()}] \leavevmode
resets the array to zero.

\item[{setMaxCounts()}] \leavevmode
set the maximum number of start tags accepted

\item[{getCounts()}] \leavevmode
returns the number of start tags

\item[{ready()}] \leavevmode
returns `true' when the required number of start tags set by `setMaxCounts' has been reached

\end{description}


\subsection{Histogram}
\label{sections/api:histogram}
Accumulate time differences into a histogram. This is a simple multiple start,
multiple stop measurement. This is a special case of the more general `TimeDifferences' measurement.
Specifically, the measurement waits for clicks on the `start channel',
and for each start click, it measures the time difference between
the start click and all subsequent clicks on the `click channel'
and stores them in a histogram.
The histogram range and resolution is specified by the number of bins
and the binwidth specified in ps.
Clicks that fall outside the histogram range are ignored.
Data accumulation is performed independently for all start clicks.
This type of measurement
is frequently referred to as `multiple start, multiple stop' measurement
and corresponds to a
full auto- or cross-correlation measurement.


\subsubsection{Arguments}
\label{sections/api:id10}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{click channel}] \leavevmode
\textless{}int\textgreater{} channel on which clicks are received

\item[{start channel}] \leavevmode
\textless{}int\textgreater{} channel on which start clicks are received

\item[{binwidth}] \leavevmode
\textless{}longlong\textgreater{} binwidth in ps

\item[{n\_bins}] \leavevmode
\textless{}int\textgreater{} the number of bins in the histogram

\end{description}


\subsubsection{Methods}
\label{sections/api:id11}\begin{description}
\item[{getData()}] \leavevmode
returns a one-dimensional array of size n\_bins containing the histogram.

\item[{getIndex()}] \leavevmode
returns a vector of size `n\_bins' containing the time bins in ps.

\item[{clear()}] \leavevmode
resets the array to zero.

\item[{setMaxCounts()}] \leavevmode
set the maximum number of start tags accepted

\item[{getCounts()}] \leavevmode
returns the number of start tags

\item[{ready()}] \leavevmode
returns `true' when the required number of start tags set by `setMaxCounts' has been reached

\end{description}


\subsection{StartStop}
\label{sections/api:startstop}
A simple start-stop measurement. This class performs a start-stop
measurement between two channels and stores the time differences
in a histogram. The histogram resolution
is specified beforehand (binwidth) but the histogram range is unlimited.
It is adapted to the largest time difference that was detected. Thus
all pairs of subsequent clicks are registered.


\subsubsection{Arguments}
\label{sections/api:id12}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{click\_channel}] \leavevmode
\textless{}int\textgreater{} channel on which stop clicks are received

\item[{start\_channel}] \leavevmode
\textless{}int\textgreater{} channel on which start clicks are received

\item[{binwidth}] \leavevmode
\textless{}longlong\textgreater{} binwidth in ps

\end{description}


\subsubsection{Methods}
\label{sections/api:id13}\begin{description}
\item[{getData()}] \leavevmode
returns a one dimensional array containing the histogram

\item[{getIndex()}] \leavevmode
returns a vector of the time bins in ps.

\item[{clear()}] \leavevmode
resets the array to zero and restarts the measurement.

\item[{ready()}] \leavevmode
returns `true' when the entire array is filled.

\end{description}


\subsection{TimeDifferences}
\label{sections/api:timedifferences}
A multidimensional histogram measurement optionally with up to three additional channels that control how to
step through the indices of the histogram array. This is a very powerful and generic measurement.
You can use it to record cross-correlation, lifetime measurements, fluorescence lifetime imaging
and many more measurements based on pulsed excitation.
Specifically, the measurement waits for a tag on the `start\_channel', then measures the
time difference between the start tag and all subsequent tags on the `click\_channel'
and stores them in a histogram. If no `start\_channel' is specified, the `click\_channel' is used as `start\_channel'
corresponding to an auto-correlation measurement.
The histogram has a number of `n\_bins' bins of binwidth `binwidth'. Clicks that fall outside the histogram range are discarded.
Data accumulation is performed independently for all start tags. This type of measurement is frequently referred to as
`single start, multiple stop' measurement and corresponds to a full auto- or cross-correlation measurement.

The data obtained from subsequent start tags can be accumulated into the same histogram (one-dimensional measurement)
or into different histograms (two-dimensional measurement). In this way you can perform more general two-dimensional
time-difference measurements. The parameter `n\_histograms' specifies the number of histograms. After each tag
on the `next\_channel', the histogram index is incremented by one (and reset to zero after reaching the last valid index.
You can also provide a synchronization trigger that resets the histogram index by
specifying a `sync\_channel'.

Typically, you will run the measurement indefinitely until stopped by the user. However, it is also possible to
specify the maximum number of rollovers of the histogram index. In this case the measurement stops when the number of
rollovers has reached the specified value. This means that both for a one-dimensional and for a
two-dimensional measurement, it will measure until every histogram has a seen the specified number of start tags.


\subsubsection{Arguments}
\label{sections/api:id14}\begin{description}
\item[{tagger}] \leavevmode
\textless{}reference\textgreater{} reference to a time tagger

\item[{click channel}] \leavevmode
\textless{}int\textgreater{} channel that increments the count in a bin

\item[{start channel}] \leavevmode
\textless{}int\textgreater{} channel that sets start times relative to which s on the click channel are measured

\item[{next channel}] \leavevmode
\textless{}int\textgreater{} channel that increments the histogram index

\item[{sync channel}] \leavevmode
\textless{}int\textgreater{} channel that resets the histogram index to zero

\item[{binwidth}] \leavevmode
\textless{}longlong\textgreater{} binwidth in ps

\item[{n\_bins}] \leavevmode
\textless{}int\textgreater{} number of bins in each histogram

\item[{n\_histograms}] \leavevmode
\textless{}int\textgreater{} number of histograms

\end{description}


\subsubsection{Methods}
\label{sections/api:id15}\begin{description}
\item[{getData()}] \leavevmode
returns a two-dimensional array of size `n\_bins' times `n\_histograms' containing the histograms.

\item[{getIndex()}] \leavevmode
returns a vector of size `n\_bins' containing the time bins in ps.

\item[{clear()}] \leavevmode
resets the array to zero.

\item[{setMaxCounts()}] \leavevmode
set the maximum number of start clicks accepted

\item[{getCounts()}] \leavevmode
returns the number of start clicks

\item[{ready()}] \leavevmode
returns `true' when the required number of start clicks set by `setMaxCounts' has been reached

\end{description}


\subsection{Dump}
\label{sections/api:dump}
Dump the time tag stream to a file in a binary format.


\subsubsection{Arguments}
\label{sections/api:id16}\begin{description}
\item[{\textless{}str\textgreater{} filename}] \leavevmode
name of the file to dump to

\end{description}


\subsubsection{Methods}
\label{sections/api:id17}\begin{description}
\item[{stop()}] \leavevmode
stop the measurement

\end{description}


\chapter{Revision History}
\label{sections/changelog:changelog}\label{sections/changelog::doc}\label{sections/changelog:revision-history}

\section{V1.0.2 - 28.07.2016}
\label{sections/changelog:v1-0-2-28-07-2016}
Major changes:
\begin{itemize}
\item {} 
LabView support including various example VIs

\item {} 
Matlab support including various example scripts

\item {} 
.net assembly / class library provided (32 and 64 bit)

\item {} 
WebApp graphical user interface to get started without writing a single line of code

\item {} 
Improved performance (multicore CPUs are supported)

\end{itemize}

API changes:
\begin{itemize}
\item {} 
reset() function added to reset a TimeTagger device to the startup state

\item {} 
getOverflowsAndClear() and clearOverflows() introduced to be able to reset the overflow counter

\item {} 
support for python 3.5 (32 and 64 bit) instead of 3.4

\end{itemize}


\section{V1.0.0}
\label{sections/changelog:v1-0-0}
initial release supporting python



\renewcommand{\indexname}{Index}
\printindex
\end{document}
